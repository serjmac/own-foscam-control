const moment = require("moment");
const path = require("path");
const fs = require("fs");
const { normalize } = require("path");
const snapShotLifeCheck = process.env.SNAPSHOT_LIFE_CHECK || 30; //days

function checkModified(file) {
  const stats = fs.statSync(file);
  console.log(`File Data Last Modified: ${stats.mtime.toDateString()}`);
  console.log("File is " + Math.floor((new Date() - new Date(stats.mtime)) / 86400000) + " day(s) old");
  if (new Date() - new Date(stats.mtime) > snapShotLifeCheck * 86400000) {
    console.log(
      `${file} discarded because it is too dated (${parseInt(
        (new Date() - new Date(stats.mtime)) / 86400000
      )} days, limit is set to ${snapShotLifeCheck})`
    );
    return "discarded";
  } else {
    console.log(
      `${file} is to be stored in DB because it is considered recent (${parseInt(
        (new Date() - new Date(stats.mtime)) / 86400000
      )} days, limit is set to ${snapShotLifeCheck})`
    );
    return "continue";
  }
}

//pool is not available without req object, coming in pool var from filewatcher callback, along with filePath var
module.exports.addSnapToDB = async (filePath, pool) => {
  console.log(filePath, "add event");
  const checkAge = await checkModified(filePath);
  console.log("checkAge result is:", checkAge);
  if (checkAge === "continue") {
    //preparing path string. Will be relative to /ftp/ app folder
    //subfolders /snap/ for snapshots and /record/ for video, which are default tree generated by Foscam FTP uploading
    const normalizedPath = filePath.split(path.sep).join(path.posix.sep).replace(/ftp\//, "");
    let file_type;
    let snapDate;
    if (normalizedPath.includes("jpg")) {
      file_type = "jpg";
      //extracting timestamp from filename, convert to dateString with moment and parse to ISODate object with new Date()
      snapDate = new Date(moment(normalizedPath.replace(/\/snap\/MDAlarm_/, "").replace(/.jpg/, ""), "YYYYMMDD-hhmmss"));
      //alternative to extract timestamp from file attributes
      //const snapDate = fs.statSync(filePath).mtime;
    }
    if (normalizedPath.includes("mkv")) {
      file_type = "mkv";
      snapDate = new Date(moment(normalizedPath.replace(/\/record\/alarm_/, "").replace(/.mkv/, ""), "YYYYMMDD-hhmmss"));
    }
    //in race condition, const sql = "INSERT INTO ftps (file_path,file_time,file_type) SELECT ?, ?, ? WHERE NOT EXISTS (SELECT file_path FROM ftps WHERE file_path= ? )";
    //might cause deadlocks when checking if not exists with multiple concurrent pool INSERT connections (ie: on app init with crowded filewatched ftp folder)
    //instead, using UNIQUE for file_path column, and rolling back if duplicate:
    const sql = "INSERT INTO ftps (file_path,file_time,file_type) SELECT ?, ?, ?";

    try {
      await pool.query("BEGIN");
      await pool.query(sql, [normalizedPath, snapDate, file_type]).then((result) => {
        if (result[0].affectedRows === 1) {
          pool.query("COMMIT").then(() => {
            console.log(`File not found in database, INSERT for ${normalizedPath} COMMITTED`);
          });
        } else {
          console.log("\x1b[33m%s\x1b[0m", `Something went wrong, no data inserted for: " + ${normalizedPath}`);
        }
      });
    } catch (error) {
      pool.query("ROLLBACK").then(() => {
        console.log("Rolling back transaction on error:");
        if (error.errno === 1062) {
          //errors to console in yellow text for duplicate in file_path table column
          console.log("\x1b[33m%s\x1b[0m", `${error.sqlMessage}, INSERT skipped`);
        } else if (error.errno === 1213) {
          console.log("\x1b[33m%s\x1b[0m", `${error.sqlMessage}, file ${normalizedPath} was not inserted because deadlock`);
        } else {
          console.error(error);
        }
      });
    }
  }
};

module.exports.deleteSnapFromDB = async (filePath, pool) => {
  console.log(filePath, "deleted event");
  const normalizedPath = filePath.split(path.sep).join(path.posix.sep).replace(/ftp\//, "");
  const sql = "DELETE FROM ftps WHERE file_path = ?";
  try {
    await pool.query(sql, [normalizedPath]).then((result) => {
      if (result[0].affectedRows === 0) {
        console.log("File not found in database, nothing to delete: (" + normalizedPath + ")");
      }
      if (result[0].affectedRows === 1) {
        console.log("File deleted from database: " + normalizedPath);
      }
    });
  } catch (error) {
    console.error(error);
  }
};

module.exports.flushResyncDB = async (req, res) => {
  console.log("flushDB route hit");
  const sql = "DELETE FROM ftps";
  try {
    //pool is available from app.locals in req object
    await req.app.locals.pool.query(sql).then(() => {
      console.log("FTP links flushed from DB, restart app to regenerate links");
      console.log("process platform is: ", process.platform);
      if (process.platform === "linux") {
        console.log("restarting app");
        const exec = require("child_process").exec;
        //CMD restart node app. View will only render access to this code if process.platform === "linux"
        const cmdRestart = "forever restart app.js";
        exec(cmdRestart, function (error, stdout, stderr) {
          if (stderr || error) {
            console.log({
              success: false,
              error: stderr || error,
              command: cmdRestart,
              result: null,
            });
          } else {
            console.log({
              success: true,
              error: null,
              command: cmdRestart,
              result: stdout,
            });
          }
        });
      }
    });
  } catch (error) {
    console.error(error);
  }
  res.render("restartwait");
};
